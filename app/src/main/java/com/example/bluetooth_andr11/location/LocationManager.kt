// üî• –û–ë–ù–û–í–õ–ï–ù–ù–´–ô EnhancedLocationManager —Å —Ä–µ–∞–ª—å–Ω—ã–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º GPS

package com.example.bluetooth_andr11.location

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.location.Location
import android.location.LocationManager
import android.os.Looper
import android.util.Log
import androidx.compose.runtime.mutableStateOf
import androidx.core.content.ContextCompat
import com.example.bluetooth_andr11.BuildConfig
import com.example.bluetooth_andr11.log.LogModule
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationAvailability
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationRequest
import com.google.android.gms.location.LocationResult
import com.google.android.gms.location.Priority
import com.google.android.gms.tasks.CancellationTokenSource
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import java.util.Locale
import android.location.LocationManager as AndroidLocationManager

class EnhancedLocationManager(
    private val context: Context,
    private val fusedLocationClient: FusedLocationProviderClient
) {
    val locationCoordinates = mutableStateOf("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
    val locationAccuracy = mutableStateOf(0f)
    val locationSource = mutableStateOf("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
    val isLocationEnabled = mutableStateOf(false)

    private var isUpdatingLocation = false
    private var locationCallback: LocationCallback? = null
    private var currentLocationMode = LocationMode.BALANCED

    // üî• –ù–û–í–û–ï: –î–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π GPS
    private var locationStatusReceiver: BroadcastReceiver? = null
    private var onLocationStatusChanged: ((Boolean) -> Unit)? = null
    private var lastKnownGpsState = false

    enum class LocationMode {
        HIGH_ACCURACY, BALANCED, LOW_POWER, PASSIVE, GPS_ONLY, NETWORK_ONLY
    }

    data class LocationInfo(
        val coordinates: String,
        val accuracy: Float,
        val source: String,
        val timestamp: Long,
        val isFromCache: Boolean = false
    )

    data class LocationStatus(
        val hasPermission: Boolean,
        val isGpsEnabled: Boolean,
        val isNetworkEnabled: Boolean,
        val isLocationAvailable: Boolean,
        val currentMode: LocationMode,
        val lastUpdate: LocationInfo
    )

    init {
        setupLocationCallback()
        checkLocationSettings()
        getLastKnownLocationAll()
        setupLocationStatusMonitoring() // üî• –ù–û–í–û–ï
    }

    // üî• –ù–û–í–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è GPS –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    private fun setupLocationStatusMonitoring() {
        locationStatusReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                when (intent?.action) {
                    LocationManager.PROVIDERS_CHANGED_ACTION -> {
                        Log.d(TAG, "üîÑ –ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è")

                        val currentGpsState = isLocationServiceEnabled(context!!)
                        val wasEnabled = lastKnownGpsState
                        lastKnownGpsState = currentGpsState

                        Log.d(TAG, "üìç GPS —Å–æ—Å—Ç–æ—è–Ω–∏–µ: –±—ã–ª–æ=$wasEnabled, —Å—Ç–∞–ª–æ=$currentGpsState")

                        // –û–±–Ω–æ–≤–ª—è–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                        isLocationEnabled.value = currentGpsState

                        // üî• –õ–û–ì–ò–†–£–ï–ú –ò–ó–ú–ï–ù–ï–ù–ò–Ø
                        if (wasEnabled != currentGpsState) {
                            val event = if (currentGpsState) {
                                "‚úÖ GPS –í–ö–õ–Æ–ß–ï–ù - –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ"
                            } else {
                                "‚ùå GPS –í–´–ö–õ–Æ–ß–ï–ù - –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ"
                            }

                            // –õ–æ–≥–∏—Ä—É–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–±—ã—Ç–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è GPS
                            logLocationStatusChange(context, event)

                            // –£–≤–µ–¥–æ–º–ª—è–µ–º callback
                            onLocationStatusChanged?.invoke(currentGpsState)
                        }

                        // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                        checkLocationSettings()
                    }
                }
            }
        }

        // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º receiver
        val filter = IntentFilter(LocationManager.PROVIDERS_CHANGED_ACTION)
        context.registerReceiver(locationStatusReceiver, filter)

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        lastKnownGpsState = isLocationServiceEnabled(context)
        Log.d(TAG, "üîÑ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ GPS –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω. –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ: $lastKnownGpsState")
    }

    // üî• –ù–û–í–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π GPS
    private fun logLocationStatusChange(context: Context, event: String) {
        try {
            // üî• –ù–û–í–û–ï: –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ GPS —Å–æ–±—ã—Ç–∏–µ–º
            val isGpsAvailable = event.contains("–í–ö–õ–Æ–ß–ï–ù") || event.contains("–¥–æ—Å—Ç—É–ø–Ω–æ")

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–º–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ LogModule
            LogModule.logGpsStateChange(context, isGpsAvailable, event)

            Log.i(TAG, "üìù GPS —Å–æ–±—ã—Ç–∏–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ —É–º–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º: $event")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå –û—à–∏–±–∫–∞ —É–º–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è GPS: ${e.message}")

            // Fallback –∫ –ø—Ä–æ—Å—Ç–æ–º—É –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—é
            val timestamp = java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(java.util.Date())
            val logMessage = "$timestamp - $event @ –°–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ\n"

            val logDir = java.io.File(context.getExternalFilesDir(null), "logs")
            if (!logDir.exists()) logDir.mkdirs()

            val logFile = java.io.File(logDir, "events_log.txt")
            logFile.appendText(logMessage)
        }
    }

    // üî• –ù–û–í–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è GPS
    private fun isLocationServiceEnabled(context: Context): Boolean {
        val locationManager = context.getSystemService(Context.LOCATION_SERVICE) as LocationManager
        return locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) ||
                locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)
    }

    // üî• –ù–û–í–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ callback –∏–∑–º–µ–Ω–µ–Ω–∏–π GPS
    fun setLocationStatusChangeListener(listener: (Boolean) -> Unit) {
        onLocationStatusChanged = listener
    }

    // üî• –ù–û–í–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ GPS
    fun forceLocationStatusCheck(): Boolean {
        val currentState = isLocationServiceEnabled(context)
        val previousState = lastKnownGpsState

        Log.d(TAG, "üîç –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ GPS: –±—ã–ª–æ=$previousState, —Å—Ç–∞–ª–æ=$currentState")

        if (previousState != currentState) {
            lastKnownGpsState = currentState
            isLocationEnabled.value = currentState

            val event = if (currentState) {
                "‚úÖ GPS –í–ö–õ–Æ–ß–ï–ù (–ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)"
            } else {
                "‚ùå GPS –í–´–ö–õ–Æ–ß–ï–ù (–ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)"
            }

            logLocationStatusChange(context, event)
            onLocationStatusChanged?.invoke(currentState)
        }

        return currentState
    }

    // üî• –£–õ–£–ß–®–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤
    fun cleanup() {
        try {
            locationStatusReceiver?.let {
                context.unregisterReceiver(it)
            }
            stopLocationUpdates()
            Log.d(TAG, "üßπ –†–µ—Å—É—Ä—Å—ã EnhancedLocationManager –æ—á–∏—â–µ–Ω—ã")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤: ${e.message}")
        }
    }

    private fun setupLocationCallback() {
        locationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                locationResult.lastLocation?.let { location ->
                    updateLocationInfo(location, false)
                }
            }

            override fun onLocationAvailability(availability: LocationAvailability) {
                val wasAvailable = isLocationEnabled.value
                isLocationEnabled.value = availability.isLocationAvailable

                // üî• –ò–ó–ú–ï–ù–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–º–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ GPS
                if (wasAvailable != availability.isLocationAvailable) {
                    LogModule.logGpsStateChange(
                        context,
                        availability.isLocationAvailable,
                        "LocationAvailability callback"
                    )
                }

                if (!availability.isLocationAvailable) {
                    Log.w(TAG, "–ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ")
                }
            }
        }
    }

    private fun updateLocationInfo(location: Location, isFromCache: Boolean = false) {
        val coordinates =
            String.format(Locale.US, "%.6f, %.6f", location.latitude, location.longitude)
        locationCoordinates.value = coordinates
        locationAccuracy.value = location.accuracy

        val source = when {
            location.isFromMockProvider -> "üß™ Mock"
            isFromCache -> "üíæ Cache"
            location.accuracy <= 10f -> "üõ∞Ô∏è GPS"
            location.accuracy <= 50f -> "üì° Network+"
            location.accuracy <= 500f -> "üì∂ Network"
            else -> "‚ùì Unknown"
        }
        locationSource.value = source

        if (BuildConfig.DEBUG) {
            Log.d(
                TAG,
                "–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã: $coordinates (¬±${location.accuracy.toInt()}–º, $source)"
            )
        }
    }

    private fun checkLocationSettings() {
        val locationManager =
            context.getSystemService(Context.LOCATION_SERVICE) as AndroidLocationManager
        val isGpsEnabled = locationManager.isProviderEnabled(AndroidLocationManager.GPS_PROVIDER)
        val isNetworkEnabled =
            locationManager.isProviderEnabled(AndroidLocationManager.NETWORK_PROVIDER)
        val hasPermission = hasLocationPermission()

        val overallEnabled = isGpsEnabled || isNetworkEnabled || hasPermission

        // üî• –õ–û–ì–ò–†–£–ï–ú –î–ï–¢–ê–õ–¨–ù–£–Æ –ò–ù–§–û–†–ú–ê–¶–ò–Æ
        if (BuildConfig.DEBUG) {
            Log.d(
                TAG,
                "üìã –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫: GPS=$isGpsEnabled, Network=$isNetworkEnabled, Permission=$hasPermission, Overall=$overallEnabled"
            )
        }

        isLocationEnabled.value = overallEnabled
    }

    // –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...
    // [–í–∫–ª—é—á–∏—Ç—å –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏]

    private fun getLastKnownLocationAll() {
        if (!hasLocationPermission()) return

        try {
            fusedLocationClient.lastLocation.addOnSuccessListener { location ->
                location?.let {
                    updateLocationInfo(it, true)
                } ?: getLastKnownFromSystem()
            }.addOnFailureListener {
                getLastKnownFromSystem()
            }
        } catch (e: SecurityException) {
            Log.e(TAG, "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è: ${e.message}")
        }
    }

    private fun getLastKnownFromSystem() {
        if (!hasLocationPermission()) return

        try {
            val locationManager =
                context.getSystemService(Context.LOCATION_SERVICE) as AndroidLocationManager
            val providers = listOf(
                AndroidLocationManager.GPS_PROVIDER,
                AndroidLocationManager.NETWORK_PROVIDER,
                AndroidLocationManager.PASSIVE_PROVIDER
            )

            var bestLocation: Location? = null
            for (provider in providers) {
                try {
                    if (locationManager.isProviderEnabled(provider)) {
                        val location = locationManager.getLastKnownLocation(provider)
                        if (location != null && isBetterLocation(location, bestLocation)) {
                            bestLocation = location
                        }
                    }
                } catch (e: Exception) {
                    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
                }
            }

            bestLocation?.let {
                updateLocationInfo(it, true)
            }
        } catch (e: SecurityException) {
            Log.e(TAG, "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è: ${e.message}")
        }
    }

    private fun isBetterLocation(location: Location, currentBestLocation: Location?): Boolean {
        if (currentBestLocation == null) return true

        val timeDelta = location.time - currentBestLocation.time
        val isSignificantlyNewer = timeDelta > 2 * 60 * 1000
        val isSignificantlyOlder = timeDelta < -2 * 60 * 1000

        return when {
            isSignificantlyNewer -> true
            isSignificantlyOlder -> false
            else -> (location.accuracy - currentBestLocation.accuracy) < 0
        }
    }

    fun setLocationMode(mode: LocationMode) {
        val oldMode = currentLocationMode
        currentLocationMode = mode

        // üî• –õ–û–ì–ò–†–£–ï–ú –ò–ó–ú–ï–ù–ï–ù–ò–ï –†–ï–ñ–ò–ú–ê
        if (oldMode != mode) {
            logLocationStatusChange(context, "üîÑ –†–µ–∂–∏–º GPS –∏–∑–º–µ–Ω–µ–Ω: $oldMode ‚Üí $mode")
        }

        if (isUpdatingLocation) {
            stopLocationUpdates()
            startLocationUpdates()
        }
    }

    private fun createLocationRequest(mode: LocationMode): LocationRequest {
        return when (mode) {
            LocationMode.HIGH_ACCURACY -> LocationRequest.Builder(
                Priority.PRIORITY_HIGH_ACCURACY,
                10000L
            )
                .setMinUpdateIntervalMillis(5000L).build()

            LocationMode.BALANCED -> LocationRequest.Builder(
                Priority.PRIORITY_BALANCED_POWER_ACCURACY,
                30000L
            )
                .setMinUpdateIntervalMillis(15000L).build()

            LocationMode.LOW_POWER -> LocationRequest.Builder(Priority.PRIORITY_LOW_POWER, 60000L)
                .setMinUpdateIntervalMillis(30000L).build()

            LocationMode.PASSIVE -> LocationRequest.Builder(Priority.PRIORITY_PASSIVE, 300000L)
                .build()

            LocationMode.GPS_ONLY -> LocationRequest.Builder(
                Priority.PRIORITY_HIGH_ACCURACY,
                15000L
            )
                .setMinUpdateIntervalMillis(10000L).build()

            LocationMode.NETWORK_ONLY -> LocationRequest.Builder(
                Priority.PRIORITY_LOW_POWER,
                20000L
            )
                .setMinUpdateIntervalMillis(10000L).build()
        }
    }

    private fun hasLocationPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
    }

    fun startLocationUpdates(onLocationUpdated: ((String) -> Unit)? = null) {
        if (!hasLocationPermission() || isUpdatingLocation) return

        val locationRequest = createLocationRequest(currentLocationMode)

        locationCallback?.let {
            fusedLocationClient.removeLocationUpdates(it)
        }

        locationCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                locationResult.lastLocation?.let { location ->
                    updateLocationInfo(location, false)
                    onLocationUpdated?.invoke("${location.latitude}, ${location.longitude}")
                }
            }

            override fun onLocationAvailability(availability: LocationAvailability) {
                val wasAvailable = isLocationEnabled.value
                isLocationEnabled.value = availability.isLocationAvailable

                if (wasAvailable != availability.isLocationAvailable) {
                    val event = if (availability.isLocationAvailable) {
                        "üì∂ –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Å—Ç–∞–ª–æ –¥–æ—Å—Ç—É–ø–Ω–æ"
                    } else {
                        "üìµ –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Å—Ç–∞–ª–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ"
                    }
                    logLocationStatusChange(context, event)
                }
            }
        }

        try {
            fusedLocationClient.requestLocationUpdates(
                locationRequest,
                locationCallback!!,
                Looper.getMainLooper()
            )
            isUpdatingLocation = true
            Log.i(TAG, "–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è –∑–∞–ø—É—â–µ–Ω—ã: $currentLocationMode")
        } catch (e: SecurityException) {
            Log.e(TAG, "–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: ${e.message}")
        }
    }

    fun stopLocationUpdates() {
        locationCallback?.let {
            fusedLocationClient.removeLocationUpdates(it)
        }
        isUpdatingLocation = false
    }

    fun getCurrentCoordinates(): String = locationCoordinates.value

    fun getLocationInfo(): LocationInfo {
        return LocationInfo(
            coordinates = locationCoordinates.value,
            accuracy = locationAccuracy.value,
            source = locationSource.value,
            timestamp = System.currentTimeMillis()
        )
    }

    fun forceLocationUpdate(mode: LocationMode = LocationMode.HIGH_ACCURACY) {
        if (!hasLocationPermission()) return

        val priority = when (mode) {
            LocationMode.HIGH_ACCURACY, LocationMode.GPS_ONLY -> Priority.PRIORITY_HIGH_ACCURACY
            LocationMode.BALANCED -> Priority.PRIORITY_BALANCED_POWER_ACCURACY
            LocationMode.LOW_POWER, LocationMode.NETWORK_ONLY -> Priority.PRIORITY_LOW_POWER
            LocationMode.PASSIVE -> Priority.PRIORITY_PASSIVE
        }

        try {
            val cancellationTokenSource = CancellationTokenSource()
            fusedLocationClient.getCurrentLocation(priority, cancellationTokenSource.token)
                .addOnSuccessListener { location ->
                    location?.let {
                        updateLocationInfo(it, false)
                        Log.i(TAG, "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–æ–ª—É—á–µ–Ω—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: ¬±${it.accuracy.toInt()}–º")
                    } ?: tryAlternativeLocationMethod(mode)
                }
                .addOnFailureListener {
                    tryAlternativeLocationMethod(mode)
                }

            CoroutineScope(Dispatchers.IO).launch {
                delay(30000)
                cancellationTokenSource.cancel()
            }
        } catch (e: SecurityException) {
            Log.e(TAG, "–û—à–∏–±–∫–∞ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: ${e.message}")
        }
    }

    private fun tryAlternativeLocationMethod(mode: LocationMode) {
        getLastKnownLocationAll()
        if (mode == LocationMode.NETWORK_ONLY || mode == LocationMode.LOW_POWER) {
            startTemporaryLocationUpdates()
        }
    }

    private fun startTemporaryLocationUpdates() {
        if (!hasLocationPermission()) return

        val locationRequest = LocationRequest.Builder(Priority.PRIORITY_LOW_POWER, 5000L)
            .setMinUpdateIntervalMillis(2000L)
            .setMaxUpdateDelayMillis(10000L)
            .build()

        val tempCallback = object : LocationCallback() {
            override fun onLocationResult(locationResult: LocationResult) {
                locationResult.lastLocation?.let { location ->
                    updateLocationInfo(location, false)
                    fusedLocationClient.removeLocationUpdates(this)
                }
            }
        }

        try {
            fusedLocationClient.requestLocationUpdates(
                locationRequest,
                tempCallback,
                Looper.getMainLooper()
            )
            CoroutineScope(Dispatchers.IO).launch {
                delay(30000)
                fusedLocationClient.removeLocationUpdates(tempCallback)
            }
        } catch (e: SecurityException) {
            Log.e(TAG, "–û—à–∏–±–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: ${e.message}")
        }
    }

    fun getLocationStatus(): LocationStatus {
        val locationManager =
            context.getSystemService(Context.LOCATION_SERVICE) as AndroidLocationManager
        return LocationStatus(
            hasPermission = hasLocationPermission(),
            isGpsEnabled = locationManager.isProviderEnabled(AndroidLocationManager.GPS_PROVIDER),
            isNetworkEnabled = locationManager.isProviderEnabled(AndroidLocationManager.NETWORK_PROVIDER),
            isLocationAvailable = isLocationEnabled.value,
            currentMode = currentLocationMode,
            lastUpdate = getLocationInfo()
        )
    }

    fun isLocationAvailable(): Boolean {
        return locationCoordinates.value != "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ" && hasLocationPermission()
    }

    fun getRecommendedMode(): LocationMode {
        val status = getLocationStatus()
        return when {
            !status.hasPermission -> LocationMode.PASSIVE
            status.isGpsEnabled && status.isNetworkEnabled -> LocationMode.BALANCED
            status.isGpsEnabled -> LocationMode.GPS_ONLY
            status.isNetworkEnabled -> LocationMode.NETWORK_ONLY
            status.hasPermission -> LocationMode.LOW_POWER
            else -> LocationMode.PASSIVE
        }
    }

    companion object {
        private const val TAG = "EnhancedLocationManager"
    }
}